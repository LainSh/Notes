# C++ - 内存管理


### 1.内存分配方式

**栈**：在执行函数时，函数内**局部变量**的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

**堆**：就是那些由**new**分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个**new**就要对应一个**delete**。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

**自由存储区**：就是那些由**malloc**等分配的内存块，他和堆是十分相似的，不过它是用**free**来结束自己的生命的。

**全局/静态存储区**：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

**常量存储区**：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。


### 2.堆和栈的区别

- 管理方式不同：
    *栈*，由编译器自动管理；
    *堆*，释放工作由程序员来控制，容易产生内存泄漏。
- 空间大小不同
    *栈*，的空间比较小；
    *堆*，的空间几乎没有什么限制。
- 能否产生碎片不同
    *栈*，不会产生碎片问题；
    *堆*，由于频繁的new/delete势必造成内存空间不连续，从而造成大量碎片，使程序效率降低。
- 生长方式不同
    *栈*，的生长方向是向下的，是向着内存地址减小的方向增长；
    *堆*，的生长方向是向上的，向着内存地址增加的方向。
- 分配方式不同
    *栈*，有两种分配方式：静态分配和动态分配，静态分配是编译器完成的，比如局部变量，动态分配是由alloca函数进行分配的，但是栈的动态分配由编译器来释放，无需我们手工实现；
    *堆*，都是动态分配的，没有静态分配的堆。
- 分配效率不同
    *栈*，是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。
    *堆*，则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。


### 3.常见的内存错误及其对策

- 内存分配未成功却使用了它。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。
- 内存分配虽然成功，但是尚未初始化就引用它。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。
- 内存分配成功并且已经初始化，但操作越过了内存边界。
- 忘记释放内存，造成内存泄漏。
- 释放了内存却继续使用它。

**五条规则**:
规则1：用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。
规则2：不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
规则3：避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。
规则4：动态内存的申请与释放必须配对，防止内存泄漏。
规则5：用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。


### 4.malloc/free和new/delete
　　malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
　　对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
　　因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

### 5.static

**static 用来控制变量的存储方式和可见性**

　　函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此 函数控制）。需要一个数据对象为整个类而非某个对象服务，同时又力求不破坏类的封装性，即要求此成员隐藏在类的内部，对外不可见。

**static 的内部机制：**
　　静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main(）函数前的全局数据声明和定义处。
　　静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。
　　static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。

**static 的优势：**
　　可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的 值是可以更新的。